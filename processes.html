
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>进程 &#8212; An Introduction to libuv</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="多路事件循环(Multiple event loops)" href="multiple.html" />
    <link rel="prev" title="线程" href="threads.html" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33699076-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>An Introduction to libuv</span></a></h1>
        <h2 class="heading"><span>进程</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="threads.html">线程</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="multiple.html">多路事件循环(Multiple event loops)</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="id1">
<h1>进程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>libuv 也提供了进程管理的功能. libuv 进程管理抽象了不同平台的差异,
并通过流和管道使得进程间通信成为可能.</p>
<p>Unix 的设计哲学是:只做一件事，并把它做好(do one thing and do it well), 因此,
一个进程通常使用多个子进程来完成不同的任务, (类似于 shell 中的管道).
基于消息的多进程模型相对于共享内存式的多线程模型也更易于理解.</p>
<p>一个对事件驱动编程的通常指责是它不能利用现代计算机的多核优势.在一个多线程程序中，内核能通过调度和将不同
线程分配给不同的CPU核心来提高性能.但是一个事件循环只有一个线程，变通方法是启动多个进程，每个进程
运行一个事件循环，并将每个进程分配到单独的CPU核心中.</p>
<div class="section" id="spawning-child-processes">
<h2>创建子进程(Spawning child processes)<a class="headerlink" href="#spawning-child-processes" title="Permalink to this headline">¶</a></h2>
<p>最简单的情形是你想要启动一个进程，并想要知道它什么时候结束.这可以通过 <code class="docutils literal"><span class="pre">uv_spawn</span></code> 完成.</p>
<p class="rubric">spawn/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_process_t</span> <span class="n">child_req</span><span class="p">;</span>
<span class="n">uv_process_options_t</span> <span class="n">options</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;mkdir&quot;</span><span class="p">;</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;test-dir&quot;</span><span class="p">;</span>
<span class="hll">    <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span>
<span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">on_exit</span><span class="p">;</span>
</span><span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="s">&quot;mkdir&quot;</span><span class="p">;</span>
</span><span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal"><span class="pre">uv_process_t</span></code> 只是一个监视的结构,所有的选项通过 <code class="docutils literal"><span class="pre">uv_process_options_t</span></code> 来设置.简单的
启动一个进程,你只要设置 <code class="docutils literal"><span class="pre">file</span></code> 和 <code class="docutils literal"><span class="pre">args</span></code> 属性. <code class="docutils literal"><span class="pre">file</span></code> 是要执行的程序. <code class="docutils literal"><span class="pre">uv_spwan</span></code>
在内部调用 <a class="reference external" href="http://www.kernel.org/doc/man-pages/online/pages/man3/exec.3.html">execvp</a> ,因此你不需要指定绝对路径.最后作为约定, <strong>参数数组要比参数个数多一个,最后的
元素要被设置为NULL</strong>.</p>
<p>在调用 <code class="docutils literal"><span class="pre">uv_spwan</span></code> 之后, <code class="docutils literal"><span class="pre">uv_process_t.pid</span></code> 保存了子进程的进程ID.</p>
<p>在进程即将结束或者收到导致结束的信号时,结束回调会被调用.</p>
<p class="rubric">spawn/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">on_exit</span><span class="p">(</span><span class="n">uv_process_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exit_status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">term_signal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Process exited with status %d, signal %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">exit_status</span><span class="p">,</span> <span class="n">term_signal</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>在进程结束之后 <strong>需要</strong> 关闭进程监视器.</p>
</div>
<div class="section" id="changing-process-parameters">
<h2>改变进程参数(Changing process parameters)<a class="headerlink" href="#changing-process-parameters" title="Permalink to this headline">¶</a></h2>
<p>在子进程启动之前，可以通过 <code class="docutils literal"><span class="pre">uv_process_potions_t</span></code> 中的结构来设置执行环境.</p>
<div class="section" id="change-execution-directory">
<h3>改变执行目录(Change execution directory)<a class="headerlink" href="#change-execution-directory" title="Permalink to this headline">¶</a></h3>
<p>设置 <code class="docutils literal"><span class="pre">uv_process_options_t.cwd</span></code> 参数改变进程的执行路径.</p>
</div>
<div class="section" id="set-environment-variables">
<h3>设置环境变量(Set environment variables)<a class="headerlink" href="#set-environment-variables" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">uv_process_options_t.env</span></code> 是一个字符串数组,每一个 <code class="docutils literal"><span class="pre">VAR=VALUE</span></code> 这样的结构用来
设置这个进程的环境变量.设置为 <code class="docutils literal"><span class="pre">NULL</span></code> 表示从父进程中继承环境变量.</p>
</div>
<div class="section" id="option-flags">
<h3>选项参数(Option flags)<a class="headerlink" href="#option-flags" title="Permalink to this headline">¶</a></h3>
<p>设置 <code class="docutils literal"><span class="pre">uv_process_options_t.flags</span></code> 下面的标志的按位或,可以修改子进程的行为.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">UV_PROCESS_SETUID</span></code> - 设置子进程的用户ID为 <code class="docutils literal"><span class="pre">uv_process_options_t.uid</span></code>.</li>
<li><code class="docutils literal"><span class="pre">UV_PROCESS_SETGID</span></code> - 设置子进程的用户组ID为 <code class="docutils literal"><span class="pre">uv_process_options_t.gid</span></code>.</li>
</ul>
<p>只有Unix支持修改UID/GID,在Windows上 <code class="docutils literal"><span class="pre">uv_spawn</span></code> 会失败，并返回 <code class="docutils literal"><span class="pre">UV_ENOTSUP</span></code></p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS</span></code> - 在Windows上对 <code class="docutils literal"><span class="pre">uv_process_options_t.args</span></code> 用引号和转义. Unix上忽略.</li>
<li><code class="docutils literal"><span class="pre">UV_PROCESS_DETACHED</span></code> - 在新会话中开始子进程, 子进程会在父进程退出后继续运行.具体看下面实例.</li>
</ul>
</div>
</div>
<div class="section" id="detaching-processes">
<h2>进程分离(Detaching processes)<a class="headerlink" href="#detaching-processes" title="Permalink to this headline">¶</a></h2>
<p>可以传人 <code class="docutils literal"><span class="pre">UV_PROCESS_DETACHED</span></code> 来启动守护进程.或者独立运行的子进程.这样父进程退出就不会影响
子进程.</p>
<p class="rubric">detach/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;sleep&quot;</span><span class="p">;</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;100&quot;</span><span class="p">;</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">options</span><span class="p">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="s">&quot;sleep&quot;</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
<span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_PROCESS_DETACHED</span><span class="p">;</span>
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Launched sleep with PID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">child_req</span><span class="p">.</span><span class="n">pid</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_unref</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">);</span>
</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>要注意的是,监视器仍在监视子进程.所以你的程序不会退出.使用如果你想 <em>创建之后不再关心
(fire-and-forget)</em>，可以调用``uv_unref()``</p>
</div>
<div class="section" id="sending-signals-to-processes">
<h2>向进程发送信号(Sending signals to processes)<a class="headerlink" href="#sending-signals-to-processes" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>libuv在Unix封装了一个标准的 <code class="docutils literal"><span class="pre">kill(2)</span></code> 系统调用,并在Windows上提供了一个类似语义的实现.有 <em>一点警告</em> :</dt>
<dd><p class="first"><code class="docutils literal"><span class="pre">SIGTERM</span></code> <code class="docutils literal"><span class="pre">SIGINT</span></code> 和 <code class="docutils literal"><span class="pre">SIGKILL</span></code> , 都会导致进程结束. <code class="docutils literal"><span class="pre">uv_kill</span></code> 的函数签名是:</p>
<div class="last highlight-c"><div class="highlight"><pre><span></span><span class="n">uv_err_t</span> <span class="nf">uv_kill</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signum</span><span class="p">);</span>
</pre></div>
</div>
</dd>
</dl>
<p>对于使用libuv启动的进程，你可以使用 <code class="docutils literal"><span class="pre">uv_process_kill</span></code> 来结束他.他的第一个参数是结构为
<code class="docutils literal"><span class="pre">uv_process_t</span></code> 的监视器,而不是进程的pid.此时 <strong>记得调用</strong> <code class="docutils literal"><span class="pre">uv_close</span></code> 来关闭监视器.</p>
</div>
<div class="section" id="signals">
<h2>信号(Signals)<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h2>
<p>TODO: update based on <a class="reference external" href="https://github.com/joyent/libuv/issues/668">https://github.com/joyent/libuv/issues/668</a></p>
<p>libuv提供一了Unix signals的封装，在Windows上也提供 <a class="reference external" href="https://github.com/joyent/libuv/blob/node-v0.9.4/include/uv.h#L1659">有限的支持</a> .</p>
<p>为了信号在libuv上良好的运作，系统会把信号发送给 <em>所有时间循环上的所有处理器</em> .使用 <code class="docutils literal"><span class="pre">uv_signal_init()</span></code>
来初始化一个处理器,并用一个事件循环关联它.在这个处理器上监听特定的信号.使用 <code class="docutils literal"><span class="pre">uv_signal_start()</span></code>
注册处理函数.每个处理器只能关联一个信号.之后调用 <code class="docutils literal"><span class="pre">uv_signal_start()</span></code> 会覆盖之前的关联.
使用 <code class="docutils literal"><span class="pre">uv_singnal_stop()</span></code> 来结束监听.这里有个小例子来示范不同的情形.</p>
<p class="rubric">signal/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;uv.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="n">uv_signal_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Signal received: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">signum</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_signal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span><span class="p">}</span>

<span class="c1">// two signal handlers in one loop</span>
<span class="kt">void</span> <span class="nf">thread1_worker</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">userp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop1</span> <span class="o">=</span> <span class="n">uv_loop_new</span><span class="p">();</span>

    <span class="n">uv_signal_t</span> <span class="n">sig1a</span><span class="p">,</span> <span class="n">sig1b</span><span class="p">;</span>
<span class="hll">    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig1a</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig1a</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
</span>
    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig1b</span><span class="p">);</span>
    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig1b</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

    <span class="n">uv_run</span><span class="p">(</span><span class="n">loop1</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// two signal handlers, each in its own loop</span>
<span class="kt">void</span> <span class="nf">thread2_worker</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">userp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop2</span> <span class="o">=</span> <span class="n">uv_loop_new</span><span class="p">();</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop3</span> <span class="o">=</span> <span class="n">uv_loop_new</span><span class="p">();</span>

    <span class="n">uv_signal_t</span> <span class="n">sig2</span><span class="p">;</span>
    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig2</span><span class="p">);</span>
    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig2</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

    <span class="n">uv_signal_t</span> <span class="n">sig3</span><span class="p">;</span>
    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig3</span><span class="p">);</span>
    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig3</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">uv_run</span><span class="p">(</span><span class="n">loop2</span><span class="p">,</span> <span class="n">UV_RUN_NOWAIT</span><span class="p">)</span> <span class="o">||</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop3</span><span class="p">,</span> <span class="n">UV_RUN_NOWAIT</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;PID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

    <span class="n">uv_thread_t</span> <span class="n">thread1</span><span class="p">,</span> <span class="n">thread2</span><span class="p">;</span>

    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread1</span><span class="p">,</span> <span class="n">thread1_worker</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread2</span><span class="p">,</span> <span class="n">thread2_worker</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">uv_thread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread1</span><span class="p">);</span>
    <span class="n">uv_thread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>发送 <code class="docutils literal"><span class="pre">SIGUSR1</span></code> 给这个进程，你会发现处理器调用了4次,每次都有一个 <code class="docutils literal"><span class="pre">uv_signal_t</span></code> .
这个处理器简单的停止了每个处理器，因此程序随之结束.发送个所有处理器的特性十分有用.一个拥有多个事件循环的服务程序能够保证在退出之前都安全的保存了数据,简单的为每个事件循环
添加一个 <code class="docutils literal"><span class="pre">SIGINT</span></code> 的监视器就可以.</p>
</div>
<div class="section" id="i-o">
<h2>子进程 I/O<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h2>
<p>一个普通的新创建的进程有自己的一套文件描述符,0、1、2分表代表 <code class="docutils literal"><span class="pre">stdin</span></code>、 <code class="docutils literal"><span class="pre">stdout</span></code> 和 <code class="docutils literal"><span class="pre">stderr</span></code>.
有时候你想要和子进程共享文件描述符.比如:也许你的程序启动了一个子命令,想要将出错信息发送到log中去
,但是忽略 <code class="docutils literal"><span class="pre">stdout</span></code> .就是你想要将子进程的 <code class="docutils literal"><span class="pre">stderr</span></code> 显示出来.libuv支持 <em>继承</em> 文件描述
符.一个简单的例子,我们运行下面这个测试程序:</p>
<p class="rubric">proc-streams/test.c</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;This is stderr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is stdout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>真正的程序 <code class="docutils literal"><span class="pre">proc-stream</span></code> 运行这个程序,并只继承 <code class="docutils literal"><span class="pre">stderr</span></code>.子进程的文件描述符用
<code class="docutils literal"><span class="pre">uv_process_options_t</span></code> 中的 <code class="docutils literal"><span class="pre">stdio</span></code> 来设置.首先设置 <code class="docutils literal"><span class="pre">stdio_count</span></code> 为想要设置的文件
描述符的数目. <code class="docutils literal"><span class="pre">uv_process_options_t.stdio</span></code> 是一个 <code class="docutils literal"><span class="pre">uv_stdio_container_t</span></code> 的数组,结构如下:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_stdio_container_s</span> <span class="p">{</span>
  <span class="n">uv_stdio_flags</span> <span class="n">flags</span><span class="p">;</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="n">uv_stream_t</span><span class="o">*</span> <span class="n">stream</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv_stdio_container_t</span><span class="p">;</span>
</pre></div>
</div>
<p>flags可以包含多个值.使用 <code class="docutils literal"><span class="pre">UV_IGNORE</span></code> 来制定不使用它.如果开始的三个 <code class="docutils literal"><span class="pre">stdio</span></code> 被设置为 <code class="docutils literal"><span class="pre">UV_IGNORE</span></code>
它们会定向到 <code class="docutils literal"><span class="pre">/dev/null</span></code> 中.</p>
<p>既然我们想要传递已经获得的文件描述符，我们使用 <code class="docutils literal"><span class="pre">UV_INHERIT_FD</span></code>.之后我们将 <code class="docutils literal"><span class="pre">stderr</span></code> 设置为 <code class="docutils literal"><span class="pre">fd</span></code>.</p>
<p class="rubric">proc-streams/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="cm">/* ... */</span>

<span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">stdio_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span>    <span class="n">uv_stdio_container_t</span> <span class="n">child_stdio</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
<span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_INHERIT_FD</span><span class="p">;</span>
</span><span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">stdio</span> <span class="o">=</span> <span class="n">child_stdio</span><span class="p">;</span>
</span>
    <span class="n">options</span><span class="p">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">on_exit</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">options</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>如果你运行 <code class="docutils literal"><span class="pre">proc_stream</span></code> ，你会发现只有”This is stderr”显示出来了.尝试将 <code class="docutils literal"><span class="pre">stdout</span></code>
设置为继承的来观察输出.</p>
<p>将这中重定向适用到流上也很简单.通过设置 <code class="docutils literal"><span class="pre">flags</span></code> 为 <code class="docutils literal"><span class="pre">UV_INHERIT_STREAM</span></code> ,并设置 <code class="docutils literal"><span class="pre">data.stream</span></code>
为父进程里面的流,子进程会将这些流当做标准IO.这可以用来实现 <a class="reference external" href="http://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a> 之类的东西.</p>
<p>一个简单的CGI脚本/程序如下:</p>
<p class="rubric">cgi/tick.c</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;tick</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;BOOM!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个CGI服务程序结合了本章和 <a class="reference internal" href="networking.html"><span class="doc">网络</span></a> 里面的内容.每个客户端在练级关闭之前被发送了10次点滴.</p>
<p class="rubric">cgi/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">on_new_connection</span><span class="p">(</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uv_tcp_t</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_tcp_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_tcp_t</span><span class="p">));</span>
    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uv_accept</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="n">invoke_cgi_script</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span>    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></div>
</td></tr></table></div>
<p>这里我们简单的接受TCP连接,并把套接字(<em>流</em>)传递给 <code class="docutils literal"><span class="pre">invoke_cgi_script</span></code> .</p>
<p class="rubric">cgi/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">invoke_cgi_script</span><span class="p">(</span><span class="n">uv_tcp_t</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span> <span class="p">{</span>

    <span class="cm">/* ... finding the executable path and setting up arguments ... */</span>

    <span class="n">options</span><span class="p">.</span><span class="n">stdio_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">uv_stdio_container_t</span> <span class="n">child_stdio</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
<span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_INHERIT_STREAM</span><span class="p">;</span>
</span><span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">;</span>
</span>    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">stdio</span> <span class="o">=</span> <span class="n">child_stdio</span><span class="p">;</span>

    <span class="n">options</span><span class="p">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">on_exit</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">options</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

<span class="hll">    <span class="n">child_req</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">;</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>这个CGI脚本的 <code class="docutils literal"><span class="pre">stdout</span></code> 设置为套接字，所以每当我们的滴答脚本打印时，都会发送给客户端.通过使用
进程，我们将读/写的缓冲任务交给操作系统.从便利性上来讲，这十分不错.我们只需要担心创建进程是份耗时的操作.</p>
</div>
<div class="section" id="pipes">
<span id="id3"></span><h2>管道(Pipes)<a class="headerlink" href="#pipes" title="Permalink to this headline">¶</a></h2>
<p>libuv的 <code class="docutils literal"><span class="pre">uv_pipe_t</span></code> 结构会让Unix程序员有些迷惑,因为它容易联系到 <code class="docutils literal"><span class="pre">|</span></code> 和 <a class="reference external" href="http://www.kernel.org/doc/man-pages/online/pages/man7/pipe.7.html">pipe(7)</a> .
但是 <code class="docutils literal"><span class="pre">uv_pipe_t</span></code> 和匿名管道没有任何关系,何况他有两种用途:</p>
<ol class="arabic simple">
<li>Stream API - 它被当做 <code class="docutils literal"><span class="pre">uv_stream_t</span></code> API的具体实现来提供FIFO, 本地文件I/O的流接口.这在 <a class="reference internal" href="filesystem.html#buffers-and-streams"><span class="std std-ref">缓冲区与流(Buffers and Streams)</span></a> 中用 <code class="docutils literal"><span class="pre">uv_pipe_open</span></code> 讨论过了.你也可以在TCP/UDP中使用它,不过它们已经有很方便的函数和结构.</li>
<li>IPC机制.``uv_pipe_t`` 可以使用 Unix域套接字(<a class="reference external" href="http://www.kernel.org/doc/man-pages/online/pages/man7/unix.7.html">Unix Domain Socket</a>) 或者 Windows命名管道(<a class="reference external" href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa365590(v=vs.85).aspx">Windows Named Pipe</a>) 实现来允许不同进程互相通讯.这点在后面讨论.</li>
</ol>
<div class="section" id="id4">
<h3>父子进程间通信<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>父进程和子进程可用通过管道来实现单向或者双向通讯. 这需要将 <code class="docutils literal"><span class="pre">uv_stdio_container_t.flags</span></code> 设置为
<code class="docutils literal"><span class="pre">UV_CREATE_PIPE</span></code> 和 <code class="docutils literal"><span class="pre">UV_READABLE_PIPE</span></code> 或者 <code class="docutils literal"><span class="pre">UV_WRITABLE_PIPE</span></code> 的位组合.读/写标示是站在
子进程的角度观察的.</p>
</div>
<div class="section" id="id5">
<h3>任意进程间通信<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>既然域套接字 <a class="footnote-reference" href="#id7" id="id6">[1]</a> 可以很好的命名，并且在文件系统中有一个位置，那么可以用它来做无关进程之间的IPC.开源
桌面环境使用的 <a href="#id8"><span class="problematic" id="id9">D-UBS_</span></a> 系统就使用域套接字作为事件通知.不同程序能过对一个上线联系或者新硬件检测做出
反应.MySQL数据库也运行一个域套接字，客户端可以通过它进行交互.</p>
<p>当使用域套接字时，套接字的创建/所有者充当服务器的角色，这就建立了一个客户端-服务端的关系.在初始化之后，通讯和TCP没有什么不同，所以我们重复使用我们的echo服务作为例子.</p>
<p class="rubric">pipe-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">uv_pipe_t</span> <span class="n">server</span><span class="p">;</span>
<span class="hll">    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">remove_sock</span><span class="p">);</span>

<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_pipe_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="s">&quot;echo.sock&quot;</span><span class="p">))</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Bind error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_listen</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">on_new_connection</span><span class="p">))</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Listen error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>我们给管道命名为 <code class="docutils literal"><span class="pre">echo.sock</span></code> ,这意味着它会在在本地目录上创建出来.在结合流API使用后，这个套接字和TPC套接字没有什么不同.
你可以使用 <a class="reference external" href="http://netcat.sf.net">netcat</a> 测试这个服务器:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span>$ nc -U /path/to/echo.sock
</pre></div>
</div>
<p>一个客户端如果想要连接域套接字可以使用下面的函数:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">uv_pipe_connect</span><span class="p">(</span><span class="n">uv_connect_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">uv_pipe_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">uv_connect_cb</span> <span class="n">cb</span><span class="p">);</span>
</pre></div>
</div>
<p>这里将 <code class="docutils literal"><span class="pre">name</span></code> 设置为 <code class="docutils literal"><span class="pre">echo.sock</span></code> 或者类似东西.</p>
</div>
<div class="section" id="sending-file-descriptors-over-pipes">
<h3>通过管道发送文件描述符(Sending file descriptors over pipes)<a class="headerlink" href="#sending-file-descriptors-over-pipes" title="Permalink to this headline">¶</a></h3>
<p>域套接字的一个很酷的特性是能够在进程之间传递文件描述符.这允许进程将他们的I/O交付给其他进程.
应用可以包含均衡负载进程，工作进程和其他方式来优化CPU的使用.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">在Windows上，只有表示TCP套接字的文件描述符能够被传递.</p>
</div>
<p>为了示范，我们来看一个采用流行的循环队列方式，将连接交付给工作进程的echo服务器.这个程序有点深入，并且只有片段
代码加入到本书中.推荐你阅读完整的代码来真正弄懂它.</p>
<p>工作进程十分简单，因为文件描述符是主进程传递过来的.</p>
<p class="rubric">multi-echo-server/worker.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_pipe_t</span> <span class="n">queue</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

<span class="hll">    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_pipe_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_read2_start</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">on_new_connection</span><span class="p">);</span>
</span>    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal"><span class="pre">queue</span></code> 是连接主进程的管道，通过它来传递文件描述符.我们使用 <code class="docutils literal"><span class="pre">read2</span></code> 函数来读取文件描述符. 重要的一点是，需要设置``uv_pipe_init`` 的 <code class="docutils literal"><span class="pre">ipc</span></code> 参数为1，来表示这个管道用作进程间通讯! 因为主进程将文件句柄写入工作进程的标准输入中，我们用 <code class="docutils literal"><span class="pre">uv_pipe_open</span></code> 来将管道连接到 <code class="docutils literal"><span class="pre">stdin</span></code> .</p>
<p class="rubric">multi-echo-server/worker.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">on_new_connection</span><span class="p">(</span><span class="n">uv_pipe_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">nread</span><span class="p">,</span> <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uv_handle_type</span> <span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">==</span> <span class="n">UV_UNKNOWN_HANDLE</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// error!</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">uv_pipe_t</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_pipe_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_pipe_t</span><span class="p">));</span>
    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_accept</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Worker %d: Accepted fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">io_watcher</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>
        <span class="n">uv_read_start</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">echo_read</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></div>
</td></tr></table></div>
<p>尽管 <code class="docutils literal"><span class="pre">accpet</span></code> 在代码中看起来有点奇怪，它实际是有意义的.``accept`` 传统意义上用来从另一个文件描述符(监听端)
获得一个文件描述符(客户端).这正是我们这里做的.从 <code class="docutils literal"><span class="pre">queue``中将文件描述符(</span> <span class="pre">``client</span></code> )取回来.
从这点上来看，工作进程做着标准的echo服务的工作.</p>
<p>现在来看主进程.我们来看是如何启动工作进程来达到负载均衡.</p>
<p class="rubric">multi-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">child_worker</span> <span class="p">{</span>
    <span class="n">uv_process_t</span> <span class="n">req</span><span class="p">;</span>
    <span class="n">uv_process_options_t</span> <span class="n">options</span><span class="p">;</span>
    <span class="n">uv_pipe_t</span> <span class="n">pipe</span><span class="p">;</span>
<span class="p">}</span> <span class="o">*</span><span class="n">workers</span><span class="p">;</span>

</pre></div>
</td></tr></table></div>
<p><code class="docutils literal"><span class="pre">child_worker</span></code> 结构封装了子进程和他们各自连接主进程的管道.</p>
<p class="rubric">multi-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setup_workers</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="c1">// launch same number of workers as number of CPUs</span>
    <span class="n">uv_cpu_info_t</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cpu_count</span><span class="p">;</span>
    <span class="n">uv_cpu_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_count</span><span class="p">);</span>
    <span class="n">uv_free_cpu_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">);</span>

    <span class="n">child_worker_count</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">;</span>

    <span class="n">workers</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">child_worker</span><span class="p">),</span> <span class="n">cpu_count</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cpu_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">child_worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">workers</span><span class="p">[</span><span class="n">cpu_count</span><span class="p">];</span>
<span class="hll">        <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span>
        <span class="n">uv_stdio_container_t</span> <span class="n">child_stdio</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="hll">        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_CREATE_PIPE</span> <span class="o">|</span> <span class="n">UV_READABLE_PIPE</span><span class="p">;</span>
</span><span class="hll">        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">;</span>
</span>        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_INHERIT_FD</span><span class="p">;</span>
        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">stdio</span> <span class="o">=</span> <span class="n">child_stdio</span><span class="p">;</span>
        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">stdio_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">on_exit</span><span class="p">;</span>
        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

        <span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">);</span> 
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Started worker %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">pid</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>在设置工作进程的过程中，我们使用灵活的liubv函数 <code class="docutils literal"><span class="pre">uv_cpu_info</span></code> 来得到CPU的个数.这样我们
能启动等数的工作进程.同样要注意，将第三个参数设置为1来将管道初始化为IPC通道.接下来我们将子进程
的 <code class="docutils literal"><span class="pre">stdin</span></code> 设置为一个可读的管道(从子进程的角度来看).到现在为止，一切都十分直观.工作进程们启动并等待文件描述符写入到他们的管道中.</p>
<p>我们在 <code class="docutils literal"><span class="pre">on_new_connection</span></code> (TCP是在``main()``函数中初始化的)函数中接受客户端套接字，并把它传递给循环队列里的下一个工作进程.</p>
<p class="rubric">multi-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">on_new_connection</span><span class="p">(</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// error!</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">uv_pipe_t</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_pipe_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_pipe_t</span><span class="p">));</span>
    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_accept</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span>        <span class="n">uv_write_t</span> <span class="o">*</span><span class="n">write_req</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_write_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_write_t</span><span class="p">));</span>
        <span class="n">dummy_buf</span> <span class="o">=</span> <span class="n">uv_buf_init</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="hll">        <span class="k">struct</span> <span class="n">child_worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">workers</span><span class="p">[</span><span class="n">round_robin_counter</span><span class="p">];</span>
</span><span class="hll">        <span class="n">uv_write2</span><span class="p">(</span><span class="n">write_req</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span>        <span class="n">round_robin_counter</span> <span class="o">=</span> <span class="p">(</span><span class="n">round_robin_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">child_worker_count</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>同样，<code class="docutils literal"><span class="pre">uv_write2</span></code> 函数处理了所有的抽象，并且它就是简单的将文件描述符作为正确的参数传递过去. 至此我们的多进程echo服务就能够运转了.</p>
<p>TODO what do the write2/read2 functions do with the buffers?</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[1]</a></td><td>在本章中域套接字也代表着Windows上的命名管道.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="threads.html">线程</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="multiple.html">多路事件循环(Multiple event loops)</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, Nikhil Marathe.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>